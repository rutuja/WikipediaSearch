<?xml version="1.0" ?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ackermann function</title></head><body>In total computable primitive recursive. All primitive recursive functions are total and computable, but the Ackermann function illustrates that not all total computable functions are primitive recursive.After Ackermanns publication    of his function (which had three nonnegative integer arguments), many authors modified it to suit various purposes, so that today "the Ackermann function" may refer to any of numerous variants of the original function. One common version, the two-argument Ackermann–Péter function, is defined as follows for nonnegative integers m and n::  A(m, n) =\begin{cases}n+1 &amp; \mbox{if } m = 0 \\A(m-1, 1) &amp; \mbox{if } m &gt; 0 \mbox{ and } n = 0 \\A(m-1, A(m, n-1)) &amp; \mbox{if } m &gt; 0 \mbox{ and } n &gt; 0.\end{cases} Its value grows rapidly, even for small inputs. For example A(4,2) is an integer of 19,729 decimal digits.  total computable primitive recursive. Sudan published the lesser-known Sudan function, then shortly afterwards and independently, in 1928, Ackermann published his function  \varphi\,\! . Ackermanns three-argument function,  \varphi(m, n, p)\,\! , is defined such that for p = 0, 1, 2, it reproduces the basic operations of addition, multiplication, and exponentiation as: \varphi(m, n, 0) = m+n,\,\! : \varphi(m, n, 1) = m\cdot n,\,\! : \varphi(m, n, 2) = m^n,\,\! and for p &gt; 2 it extends these basic operations in a way that happens to be expressible in Knuths up-arrow notation as: \varphi(m, n, p) = m\uparrow^{p - 1}(n + 1).\,\! (Aside from its historic role as a total-computable-but-not-primitive-recursive function, Ackermanns original function is seen to extend the basic arithmetic operations beyond exponentiation, although not as seamlessly as do variants of Ackermanns function that are specifically designed for that purpose — such as Reuben Goodstein|Goodsteins hyperoperation sequence.)In On the Infinite, David Hilbert hypothesized that the Ackermann function was not primitive recursive, but it was Ackermann, Hilbert’s personal secretary and former student, who actually proved the hypothesis in his paper On Hilbert’s Construction of the Real Numbers. On the Infinite was Hilbert’s most important paper on the foundations of mathematics, serving as the heart of Hilberts program to secure the foundation of transfinite numbers by basing them on finite methods.  Rózsa Péter and Raphael Robinson later developed a two-variable version of the Ackermann function that became preferred by many authors.  recursively as follows for nonnegative integers m, n, and p::  \varphi(m,n,p) = \begin{cases}\varphi(m, n, 0) = m + n \\\varphi(m, 0, 1) = 0 \\\varphi(m, 0, 2) = 1 \\\varphi(m, 0, p) = m &amp;\text{ for } p &gt; 2 \\\varphi(m, n, p) = \varphi(m, \varphi(m, n-1, p), p - 1) &amp;\text{ for } n &gt; 0 \text{ and } p &gt; 0.\end{cases}\,\! Of the various two-argument versions, the one developed by Péter and Robinson (called "the" Ackermann function by some authors) is defined for nonnegative integers m and n as follows::  A(m, n) =\begin{cases}n+1 &amp; \mbox{if } m = 0 \\A(m-1, 1) &amp; \mbox{if } m &gt; 0 \mbox{ and } n = 0 \\A(m-1, A(m, n-1)) &amp; \mbox{if } m &gt; 0 \mbox{ and } n &gt; 0.\end{cases} It may not be immediately obvious that the evaluation of   A(m, n)  always terminates. However, the recursion is bounded because in each recursive application either m decreases, or m remains the same and n decreases. Each time that n reaches zero, m decreases, so m eventually reaches zero as well. (Expressed more technically, in each case the pair (m, n) decreases in the lexicographic order, which preserves the well-ordering of the non-negative integers.) However, when m decreases there is no upper bound on how much n can increase — and it will often increase greatly.The Péter-Ackermann function can also be expressed in terms of various other versions of the Ackermann function:* the indexed version of Knuths up-arrow notation (extended to integer indices ≥ -2):::A(m, n) =  2\uparrow^{m-2} (n+3) - 3. :The part of the definition A(m, 0) = A(m-1, 1) corresponds to  2\uparrow^{m+1} 3=2\uparrow^m 4. * hyper operators:::A(m, n) = hyper(2, m, n + 3) − 3.* Conway chained arrow notation:::A(m, n) = (2 → (n+3) → (m − 2)) − 3 for m&amp;nbsp;&gt;&amp;nbsp;2:hence::2 → n → m = A(m+2,n-3) + 3 for n&gt;2.:(n=1 and n=2 would correspond with A(m,−2)&amp;nbsp;=&amp;nbsp;−1 and A(m,−1)&amp;nbsp;=&amp;nbsp;1, which could logically be added.)For small values of m like 1, 2, or 3, the Ackermann function grows relatively slowly with respect to n (at most exponential growth|exponentially). For m ≥ 4, however, it grows much more quickly; even A(4,&amp;nbsp;2) is about 2 , and the decimal expansion of A(4,&amp;nbsp;3) is very large by any typical measure.If we define the function f&amp;nbsp;(n)&amp;nbsp;=&amp;nbsp;A(n,&amp;nbsp;n), which increases both m and n at the same time, we have a function of one variable that dwarfs every primitive recursive function, including very fast-growing functions such as the exponential function, the factorial function, multi- and superfactorial functions, and even functions defined using Knuths up-arrow notation (except when the indexed up-arrow is used).This extreme growth can be exploited to show that f, which is obviously computable on a machine with infinite memory such as a Turing machine and so is a computable function, grows faster than any primitive recursive function and is therefore not primitive recursive. In a category with exponentials, using the isomorphism  A \times B \rightarrow C \cong A \rightarrow (B \rightarrow C)  (in computer science, this is called currying), the Ackermann function may be defined via primitive recursion over higher-order functionals as follows:: \begin{array}{lcl}\operatorname{Ack}(0) &amp; = &amp; \operatorname{Succ} \\\operatorname{Ack}(m+1) &amp; = &amp; \operatorname{Iter}(\operatorname{Ack}(m))\end{array} where Succ is the usual successor function and Iter is defined by primitive recursion as well:: \begin{array}{lcl}\operatorname{Iter}(f)(0) &amp; = &amp; f(1) \\\operatorname{Iter}(f)(n+1) &amp; = &amp; f(\operatorname{Iter}(f)(n)).\end{array} One interesting aspect of the Ackermann function is that the only arithmetic operations it ever uses are addition and subtraction of 1. Its properties come solely from the power of unlimited recursion. This also implies that its running time is at least proportional to its output, and so is also extremely huge. In actuality, for most cases the running time is far larger than the output; see below.Computing the Ackermann function can be restated in terms of an infinite table. We place the natural numbers along the top row. To determine a number in the table, take the number immediately to the left, then look up the required number in the previous row, at the position given by the number just taken. If there is no number to its left, simply look at the column headed "1" in the previous row. Here is a small upper-left portion of the table:{| class="wikitable"|+ Values of A(m,&amp;nbsp;n)|-! m\n! 0! 1! 2! 3! 4! n|-! 0| 1 || 2 || 3 || 4 || 5 ||  n + 1 |-! 1| 2 || 3 || 4 || 5 || 6 ||  n + 2 = 2 + (n + 3) - 3 |-! 2| 3 || 5 || 7 || 9 || 11 ||  2n + 3 = 2\cdot(n + 3) - 3 |-! 3| 5 || 13 || 29 || 61 || 125 ||  2^{(n+3)} - 3 |-! 4| 13   = {2^{2^{2}}}-3 || 65533   = {2^{2^{2^{2}}}}-3 | 2 65536 &amp;nbsp;−&amp;nbsp;3   = {2^{2^{2^{2^{2}}}}}-3 |  {2^{2^{65536}}} - 3    = {2^{2^{2^{2^{2^{2}}}}}}-3 |  {2^{2^{2^{65536}}}} - 3    = {2^{2^{2^{2^{2^{2^{2}}}}}}}-3 |  \begin{matrix}\underbrace }} - 3 \\n\mbox{ + 3}\end{matrix} |}The numbers listed here in a recursive reference are very large and cannot be easily notated in some other form. Knuth arrows. This number is constructed with a technique similar to applying the Ackermann function to itself recursively.This is a repeat of the above table, but with the values replaced by the relevant expression from the function definition to show the pattern clearly:{| class="wikitable"|+ Values of A(m,&amp;nbsp;n)|-! m\n! 0! 1! 2! 3! 4! n|-! 0| 0+1 || 1+1 || 2+1 || 3+1 || 4+1 ||  n + 1 |-! 1| A(0,1) || A(0,A(1,0)) || A(0,A(1,1)) || A(0,A(1,2)) || A(0,A(1,3)) ||  n + 2 = 2 + (n + 3) - 3 |-! 2| A(1,1) || A(1,A(2,0)) || A(1,A(2,1)) || A(1,A(2,2)) || A(1,A(2,3)) ||  2n + 3 = 2\cdot(n + 3) - 3 |-! 3| A(2,1) || A(2,A(3,0)) || A(2,A(3,1)) || A(2,A(3,2)) || A(2,A(3,3)) ||  2^{(n+3)} - 3 |-! 4| A(3,1) || A(3,A(4,0)) || A(3,A(4,1)) || A(3,A(4,2)) || A(3,A(4,3)) || \begin{matrix}\underbrace }} - 3 \\n\mbox{ + 3}\end{matrix} |-! 5| A(4,1) || A(4,A(5,0)) || A(4,A(5,1)) || A(4,A(5,2)) || A(4,A(5,3)) ||A(4,&amp;nbsp;A(5,&amp;nbsp;n-1))|-! 6| A(5,1) || A(5,A(6,0)) || A(5,A(6,1)) || A(5,A(6,2)) || A(5,A(6,3)) ||A(5,&amp;nbsp;A(6,&amp;nbsp;n-1))|}To see how the Ackermann function grows so quickly, it helps to expand out some simple expressions using the rules in the original definition. For example, we can fully evaluate  A(1, 2)  in the following way:: \begin{align}A(1,2) &amp; = A(0, A(1, 1)) \\&amp; = A(0, A(0, A(1, 0))) \\&amp; = A(0, A(0, A(0, 1))) \\&amp; = A(0, A(0, 2)) \\&amp; = A(0, 3) \\&amp; = 4.\end{align} To demonstrate how  A(4, 3) s computation results in many steps and in a large number:: \begin{align}A(4, 3) &amp; = A(3, A(4, 2)) \\&amp; = A(3, A(3, A(4, 1))) \\&amp; = A(3, A(3, A(3, A(4, 0)))) \\&amp; = A(3, A(3, A(3, A(3, 1)))) \\&amp; = A(3, A(3, A(3, A(2, A(3, 0))))) \\&amp; = A(3, A(3, A(3, A(2, A(2, 1))))) \\&amp; = A(3, A(3, A(3, A(2, A(1, A(2, 0)))))) \\&amp; = A(3, A(3, A(3, A(2, A(1, A(1, 1)))))) \\&amp; = A(3, A(3, A(3, A(2, A(1, A(0, A(1, 0))))))) \\&amp; = A(3, A(3, A(3, A(2, A(1, A(0, A(0, 1))))))) \\&amp; = A(3, A(3, A(3, A(2, A(1, A(0, 2)))))) \\&amp; = A(3, A(3, A(3, A(2, A(1, 3))))) \\&amp; = A(3, A(3, A(3, A(2, A(0, A(1, 2)))))) \\&amp; = A(3, A(3, A(3, A(2, A(0, A(0, A(1, 1))))))) \\&amp; = A(3, A(3, A(3, A(2, A(0, A(0, A(0, A(1, 0)))))))) \\&amp; = A(3, A(3, A(3, A(2, A(0, A(0, A(0, A(0, 1)))))))) \\&amp; = A(3, A(3, A(3, A(2, A(0, A(0, A(0, 2)))))) \\&amp; = A(3, A(3, A(3, A(2, A(0, A(0, 3))))) \\&amp; = A(3, A(3, A(3, A(2, A(0, 4))))) \\&amp; = A(3, A(3, A(3, A(2, 5)))) \\&amp; = ... \\&amp; = A(3, A(3, A(3, 13))) \\&amp; = ... \\&amp; = A(3, A(3, 65533)) \\&amp; = ... \\&amp; = A(3, 2^{65536} - 3) \\&amp; = ... \\&amp; = 2^{2^{ \overset{65536}{} }} - 3. \\\end{align} Written as a power of 10, this is roughly equivalent to 10 6.031  .Since the function &amp;nbsp;f&amp;nbsp;(n)&amp;nbsp;=&amp;nbsp;A(n,&amp;nbsp;n) considered above grows very rapidly, its inverse function, f −1 , grows very slowly. This inverse Ackermann function f −1  is usually denoted by α. In fact, α(n) is less than 5 for any practical input size n, since A(4,&amp;nbsp;4) is on the order of  2^{2^{10^{19729}}} . complexity of some algorithms, such as the disjoint-set data structure and Bernard Chazelle|Chazelles algorithm for minimum spanning trees. Sometimes Ackermanns original function or other variations are used in these settings, but they all grow at similarly high rates. In particular, some modified functions simplify the expression by eliminating the −3 and similar terms.A two-parameter variation of the inverse Ackermann function can be defined as follows, where  \lfloor x \rfloor  is the floor function:: \alpha(m,n) = \min\{i \geq 1 : A(i,\lfloor m/n \rfloor) \geq \log_2 n\}. This function arises in more precise analyses of the algorithms mentioned above, and gives a more refined time bound. In the disjoint-set data structure, m represents the number of operations while n represents the number of elements; in the minimum spanning tree algorithm, m represents the number of edges while n represents the number of vertices.Several slightly different definitions of α(m,&amp;nbsp;n) exist; for example, log 2 &amp;nbsp;n is sometimes replaced by n, and the floor function is sometimes replaced by a ceiling function|ceiling.Other studies might define an inverse function of one where m is set to a constant, such that the inverse applies to a particular row. The Ackermann function, due to its definition in terms of extremely deep recursion, can be used as a benchmark of a compilers ability to optimize recursion. The first use of Ackermanns function in this way was by Yngve Sundblad, The Ackermann function. A Theoretical, computational and formula manipulative study. (BIT 11 (1971), 107119). Whetstone benchmark) in a trilogy of papers written between 1975 and 1982.   For example, a compiler which, in analyzing the computation of A(3,&amp;nbsp;30), is able to save intermediate values like A(3,&amp;nbsp;n) and A(2,&amp;nbsp;n) in that calculation rather than recomputing them, can speed up computation of A(3,&amp;nbsp;30) by a factor of hundreds of thousands. Also, if A(2,&amp;nbsp;n) is computed directly rather than as a recursive expansion of the form A(1,&amp;nbsp;A(1,&amp;nbsp;A(1,...A(1,&amp;nbsp;0)...))), this will save significant amounts of time. Computing A(1,&amp;nbsp;n) takes linear time in n. Computing A(2,&amp;nbsp;n) requires quadratic time, since it expands to Big O notation|O(n) nested calls to A(1,&amp;nbsp;i) for various i. Computing A(3,&amp;nbsp;n) requires time proportionate to 4 n+1 . The computation of A(3,&amp;nbsp;1) in the example above takes 16 (4 2 ) steps.A(4,&amp;nbsp;2) cannot possibly be computed by simple recursive application of the Ackermann function in any tractable amount of time. Instead, shortcut formulas such as A(3,&amp;nbsp;n) = 8×2 n −3 are used as an optimization to complete some of the recursive calls.A practical method of computing functions similar to Ackermanns is to use memoization  of intermediate results. A compiler could apply this technique to a function automatically using Donald Michies "memo functions".   In The Book of Numbers, John Horton Conway and Richard K. Guy define the sequence of Ackermann numbers to be 1↑1, 2↑↑2, 3↑↑↑3, etc.;  that is, the n-th Ackermann number is defined to be n↑ n n (n = 1, 2, 3, ...), where m↑ k n is Knuths up-arrow notation|Knuths up-arrow version of the Ackermann function.The first few Ackermann numbers are::* 1↑1 = 1 1  = 1,:* 2↑↑2 = 2↑2 = 2 2  = 4,:* 3↑↑↑3 = 3↑↑3↑↑3 = 3↑↑(3↑3↑3) =  3\uparrow\uparrow3^{3^3} = 3\uparrow\uparrow7625597484987 = \underbrace{3^{3^{3^{3^{.^{.^{.^{3}}}}}}}}_{7625597484987{\rm\ threes}} The fourth Ackermann number, 4↑↑↑↑4, can be written in terms of tetration towers as follows::4↑↑↑↑4 = 4↑↑↑4↑↑↑4↑↑↑4 = 4↑↑↑4↑↑↑(4↑↑4↑↑4↑↑4):::  = \underbrace{~~^{^{^{^{^{^{^{^{4}.}.}.}4}4}4}4}4~~}_{\underbrace{~^{^{^{^{^{4}.}.}.}4}4~}_{^{^{^{^4}4}4}4 {\rm\ fours}} {\rm fours}} Explanation: in the middle layer, there is a tower of tetration whose full height is  ^{^{^{^4}4}4}4  and the final result is the top layer of tetrated 4s whose full height equals the calculation of the middle layer. Note that by way of size comparison, the simple expression  4 4 already exceeds a googolplex, so the fourth Ackermann number is quite large.Alternatively, this can be written in terms of exponentiation towers as: 4\uparrow\uparrow\uparrow\uparrow 4 =  : \quad : \left.\begin{matrix} 4^{4^{\cdot^{\cdot^{\cdot^{\cdot^{4}}}}}}\end{matrix}\right \}\left.\begin{matrix}4^{4^{\cdot^{\cdot^{\cdot^{4}}}}}\end{matrix}\right \}\dots\left.\begin{matrix}4^{4^{4^4}}\end{matrix}\right \}4, :where the number of towers on the previous line (including the rightmost "4") is: \left.\begin{matrix}4^{4^{\cdot^{\cdot^{\cdot^{\cdot^{4}}}}}}\end{matrix}\right \}\left.\begin{matrix}4^{4^{\cdot^{\cdot^{\cdot^{4}}}}}\end{matrix}\right \}\dots\left.\begin{matrix}4^{4^{4^4}}\end{matrix}\right \}4, :where the number of towers on the previous line (including the rightmost "4") is: \left.\begin{matrix}4^{4^{\cdot^{\cdot^{\cdot^{4}}}}}\end{matrix}\right \}\left.\begin{matrix}4^{4^{\cdot^{\cdot^{\cdot^{4}}}}}\end{matrix}\right \}\left.\begin{matrix}4^{4^{4^4}}\end{matrix}\right \}4, where the number of "4"s in each tower, on each of the lines above, is specified by the value of the next tower to its right (as indicated by a brace). Computability theory* Recursion (computer science)* Primitive recursive function* Double recursion   *  *  * Scott Aaronson,   (1999)*  . Includes a table of some values.*  *   describes several variations on the definition of A.* Gabriel Nivasch,   on the inverse Ackermann function.* Raimund Seidel,   (PDF presentation).*  , (on Rosetta Code)*   (  2009-10-24) - some study and programming by Harry J. Smith</body></html>