<?xml version="1.0" ?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ada (programming language)</title></head><body> computer programming Pascal and other languages. It has strong built-in language support for explicit concurrency, offering tasks, synchronous message passing (via guarded task entries), protected objects (a monitor-like construct with additional guards as in conditional critical regions) and nondeterminism (via select statements).   CII Honeywell strongly typed and compilers are validated for reliability in mission-critical applications, such as avionics software. Ada is an international standard; the current version (known as Ada 2005) is defined by joint ISO/ANSI standard,  combined with major Amendment ISO/IEC 8652:1995/Amd 1:2007. Ada was named after Ada Lovelace (1815–1852), who is sometimes credited as being the first computer programmer.  embedded and real-time computing|real-time systems. The Ada&amp;nbsp;95 revision, designed by Tucker Taft|S. Tucker Taft of Intermetrics between 1992 and 1995, improved support for systems, numerical, financial, and object-oriented programming (OOP). strong typing, modularity mechanisms (packages), run-time checking, parallel processing (Task (computing)|tasks, synchronous Message passing, protected objects and nondeterministic select statements), exception handling, and generic programming|generics. Ada&amp;nbsp;95 added support for object-oriented programming, including dynamic dispatch.The syntax of Ada is simple, consistent and readable. It minimizes choices of ways to perform basic operations, and prefers English keywords (e.g. "or else") to symbols (e.g. "||"). Ada uses the basic mathematical symbols (i.e.: "+", "-", "*" and "/") for basic mathematical operations but avoids using other symbols. Code blocks are delimited by words such as "declare", "begin" and "end", whereas the "end" (in most cases) is followed by the identifier of the block it closes (e.g. if.. end if, loop ... end loop). In the case of conditional blocks this avoids a dangling else that could pair with the wrong nested if-expression in other languages; for example, C or Java.Ada is designed for development of very large software systems. Ada packages can be compiled separately, and furthermore, Ada package specifications (the package interface) can be compiled separately without the implementation to check for consistency - this makes it possible to detect problems early during the design phase, before implementation starts. A large number of compile-time checks are supported to help avoid bugs that would not be detectable until run-time in some other languages or would require explicit checks to be added to the source code.  For example, the syntax requires explicitly named closing of blocks to prevent errors due to mismatched end tokens. The adherence to strong typing allows detection of many common software errors (wrong parameters, range violations, invalid references, mismatched types, etc.) either during compile-time, or otherwise during run-time. As concurrency is part of the language specification, the compiler can in some cases detect potential deadlocks. Compilers also commonly check for misspelled identifiers, visibility of packages, redundant declarations, etc. and can provide warnings and useful suggestions on how to fix the error. anomaly might lead to very serious consequences, e.g., accidental death, injury or severe financial loss. Examples of systems where Ada is used include avionics, railways, banking, military and space technology.     Adas dynamic memory management is high-level and type-safe.  Ada does not have generic (and vague) "pointers"; nor does it implicitly declare any pointer type.  Instead, all dynamic memory allocation and deallocation must take place through explicitly declared access types.Each access type has an associated storage pool that handles the low-level details of memory management; the programmer can either use the default storage pool or define new ones (this is particularly relevant for Non-Uniform Memory Access).  It is even possible to declare several different access types that all designate the same type but use different storage pools.Also, the language provides for accessibility checks, both at compile time and at run time, that ensures that an access value cannot outlive the type of the object it points to. garbage collection of inaccessible objects, most implementations do not support it by default, as it would cause unpredictable behaviour in real-time systems.  Ada does support a limited form of region-based storage management; also, creative use of storage pools can provide for a limited form of automatic garbage collection, since destroying a storage pool also destroys all the objects in the pool.Ada was designed to use the English language standard for  , as a double-  characters are allowed in comments, such as for symbolic formulas (E =m×c²). To the compiler, the double-dash is treated as end-of-line, allowing continued parsing of the language as a context-free grammar.The semicolon (";") is a statement terminator, and the null or no-operation statement is  null; . A single  ;  without a statement to terminate is not allowed. This allows for a better quality of error messages.Code for complex systems is typically maintained for many years, by programmers other than the original author. It can be argued that these language design principles apply to most software projects, and most phases of software development, but when applied to complex, safety critical projects, benefits in correctness, reliability, and maintainability take precedence over (arguable) costs in initial development. ISO standards, the Ada language definition (known as the Ada Reference Manual or ARM, or sometimes the Language Reference Manual or LRM) is free content. Thus, it is a common reference for Ada programmers and not just programmers implementing Ada compilers. Apart from the reference manual, there is also an extensive rationale document which explains the language design and the use of various language constructs. This document is also widely used by programmers. When the language was revised, a new rationale document was written.One notable free software tool that is used by many Ada programmers to aid them in writing Ada source code is GPS, the GNAT Programming Studio. US Department of Defense (DoD) was concerned by the number of different programming languages being used for its embedded computer system projects, many of which were obsolete or hardware-dependent, and none of which supported safe modular programming. In 1975, a working group, the High Order Language Working Group (HOLWG), was formed with the intent to reduce this number by finding or creating a programming language generally suitable for the departments requirements. The result was Ada. The total number of high-level programming languages in use for such projects fell from over 450 in 1983 to 37 by 1996.  The HOLWG working group crafted the Steelman language requirements, a series of documents stating the requirements they felt a programming language should satisfy. Many existing languages were formally reviewed, but the team concluded in 1977 that no existing language met the specifications. Augusta Ada, LIS that Ichbiah and his group had developed in the 1970s. The preliminary Ada reference manualwas published in ACM SIGPLAN Notices in June 1979. The Military Standard reference manual was approved on December 10, 1980 (Ada Lovelaces birthday), andgiven the number MIL-STD-1815 in honor of Ada Lovelaces birth year. In 1981, C. A. R. Hoare took advantage of his Turing Award speech to criticize Ada for being overly complex and hence unreliable,  but subsequently seemed to recant in the foreword he wrote for an Ada textbook. Ada attracted much attention from the programming community as a whole during its early days.  Its backers and others predicted that it might become a dominant language for general purpose programming and not just defense-related work.  Ichbiah publicly stated that within ten years, only two programming languages would remain, Ada and Lisp (programming language)|Lisp. J-P. Rosen, "The Ada Paradox(es)", Ada Letters, ACM SIGAda, Vol. 24, No. 2, August 2009, pp. 28-35.   Early Ada compilers struggled to implement the large, complex language, and both compile-time and run-time performance tended to be slow and tools primitive.  Compiler vendors expended most of their efforts in passing the massive, language-conformance-testing, government-required "ACVC" validation suite that was required in another novel feature of the Ada language effort. The first validated Ada implementation was the NYU Ada/Ed translator,  certified on April 11, 1983. NYU Ada/Ed is implemented in the high-level set language SETL.  , Countess of Lovelace.]]In 1987, the US Department of Defense began to require the use of Ada (the Ada mandate) for every software project where new code was more than 30% of result, though exceptions to this rule were often granted.By the late 1980s and early 1990s, Ada compilers had improved in performance, but there were still barriers to full exploitation of Adas abilities, including a tasking model that was different from what most real-time programmers were used to.  NATO countries.Because of Adas safety-critical support features, it is now used not only for military applications, but also in commercial projects where a software bug can have severe consequences, e.g. aviation and air traffic control, commercial rockets (e.g. Ariane 4 and 5), satellites and other space systems, railway transport and banking.   SLOC count). It featured advanced distributed processing, a distributed Ada database, and object-oriented design. Ada is also used in other air traffic systems, e.g. the UK’s next-generation Interim Future Area Control Tools Support (iFACTS) air traffic control system is designed and implemented using SPARK Ada    French Transmission TVM in-cab signalling system on the TGV high speed rail system, and the metro suburban trains in Paris, London, Hong Kong and New York City.   ANSI standard in 1983 ( ), and without any further changes became ISO standard in 1987 (ISO-8652:1987). This version of the language is commonly known as Ada&amp;nbsp;83, from the date of its adoption by ANSI, but is sometimes referred to also as Ada&amp;nbsp;87, from the date of its adoption by ISO.Ada&amp;nbsp;95, the joint ISO/ANSI standard ( ) was published in February 1995, making Ada&amp;nbsp;95 the first ISO standard object-oriented programming language. To help with the standard revision and future acceptance, the US Air Force funded the development of the GNAT Compiler. Presently, the GNAT Compiler is part of the GNU Compiler Collection.Work has continued on improving and updating the technical content of the Ada programming language. A Technical Corrigendum to Ada&amp;nbsp;95 was published in October 2001, and a major Amendment,  , the current version of the standard, was published on March 9, 2007. Work on the next significant Ada Amendment is planned to be completed by 2012.( )Other related standards include ISO 8651-3:1988 Information processing systems—Computer graphics—Graphical Kernel System (GKS) language bindings—Part 3: Ada. type definitions, record (computer science)|records, pointer (computer programming)|pointers, enumerated type|enumerations. Such constructs were in part inherited or inspired from Pascal (programming language)|Pascal.== syntax is the Hello world program: (A more in-depth example can be  )(hello.adb) with Ada.Text_IO; use Ada.Text_IO;procedure Hello isbegin  Put_Line("Hello, world!");end Hello; This program can be compiled e.g. by using the freely available open source compiler GNAT, by executing gnatmake hello.adb ==Adas type system is not based on a set of predefined primitive types but allows users to declare their own types. This declaration in turn is not based on the internal representation of the type but on describing the goal which should be achieved. This allows the compiler to determine a suitable memory size for the type, and to check for violations of the type definition at compile time and run time (i.e. range violations, buffer overruns, type consistency, etc.). Ada supports numerical types defined by a range, modulo types, aggregate types (records and arrays), and enumeration types. Access types define a reference to an instance of a specified type; untyped pointers are not permitted.Special types provided by the language are task types and protected types. For example a date might be represented as: type Day_type   is range    1 ..   31;type Month_type is range    1 ..   12;type Year_type  is range 1800 .. 2100;type Hours is mod 24;type Weekday is (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday); type Date is   record     Day   : Day_type;     Month : Month_type;     Year  : Year_type;   end record;  Types can have modifiers such as limited, abstract, private etc. Private types can only be accessed and limited types can only be modified or copied within the scope of the package that defines them. Ada 95 adds additional features for object-oriented extension of types.This simple example could be extended to show more features as: type Working_Hours is range 0..12; -- at most 12 Hours to work a daysubtype Working_Day is Weekday range Monday .. Friday; -- Days to workWork_Load: constant array(Working_Day) of Working_Hours -- Declaration   := ( Friday =&gt; 6, Monday=&gt;4, others =&gt; 10); --lookup table for working hours with initialization == go to commands is seldom needed. while a /= b loop  Ada.Text_IO.Put_Line ("Waiting");end loop;if a &gt; b then  Ada.Text_IO.Put_Line ("Condition met");else  Ada.Text_IO.Put_Line ("Condition not met");end if;for i in 1 .. 10 loop  Ada.Text_IO.Put ("Iteration: ");  Ada.Text_IO.Put (i);  Ada.Text_IO.Put_Line;end loop;loop  a := a + 1;  exit when a = 10;end loop;case i is  when 0 =&gt; Ada.Text_IO.Put("zero");  when 1 =&gt; Ada.Text_IO.Put("one");  when 2 =&gt; Ada.Text_IO.Put("two");  -- case statements have to cover all possible cases:  when others =&gt; Ada.Text_IO.Put("none of the above");  end case; with the extension above e.g. Working_Day for aWeekday in WeekdayRange loop -- loop over an enumeration   Put_Line(WeekdayImage(AWeekday) ); --output string representation of an enumeration   if AWeekday in Working_Day then -- check of a subtype of an enumeration Put_Line(" to work for" &amp; Working_HoursImage(Work_Load(aWeekday))); --access into a lookup table   end if;end loop; ==Ada programs consist of packages, procedures and functions.Example: Package specification (example.ads) package Example is     type Number is range 1 .. 11;     procedure Print_and_Increment (j: in out Number);end Example; package implementation (example.adb) with Ada.Text_IO; package body Example is  i : Number := NumberFirst;     procedure Print_and_Increment (j: in out Number) is      function Next (k: in Number) return Number is    begin      return k + 1;    end Next;    begin    Ada.Text_IO.Put_Line (The total is:  &amp; NumberImage(j));    j := Next (j);  end Print_and_Increment;  begin  while i &lt; NumberLast loop    Print_and_Increment (i);  end loop;end Example; Packages, procedures and functions can nest to any depth and each can also be the logical outermost block.Each package, procedure or function can have its own declarations of constants, types, variables, and other procedures, functions and packages, which can be declared in any order.==Ada has language support for task-based concurrency. The fundamental concurrent unit in Ada is a task which is a built-in limited type. Tasks are specified in two parts - the task declaration defines the task interface (similar to a type declaration), the task body specifies the implementation of the task.Depending on the implementation, Ada tasks are either mapped to operating system tasks or processes, or are scheduled internally by the Ada runtime. synchronous message passing). Task entries are declared in the task specification. Each task entry can have one or more accept statements within the task body. If the control flow of the task reaches an accept statement, the task is blocked until the corresponding entry is called by another task (similarly, a calling task is blocked until the called task reaches the corresponding accept statement). Task entries can have parameters similar to procedures, allowing tasks to synchronously exchange data. In conjunction with select statements it is possible to define guards on accept statements (similar to Dijkstras guarded commands).Ada also offers protected object|protected objects for mutual exclusion. Protected objects are a Monitor (synchronization)|monitor-like construct, but use guards  instead of conditional variables for signaling (similar to conditional critical regions). Protected objects combine the data encapsulation and safe mutual exclusion from monitors, and entry guards from conditional critical regions.  The main advantage over classical monitors is that conditional variables are not required for signaling, avoiding potential deadlocks due to incorrect locking semantics. Like tasks, the protected object is a built-in limited type, and it also has a declaration part and a body. A protected object consists of encapsulated private data (which can only be accessed from within the protected object), and procedures, functions and entries which are guaranteed to be mutually exclusive (with the only exception of functions, which are required to be side effect free and can therefore run concurrently with other functions). A task calling a protected object is blocked if another task is currently executing inside the same protected object, and released when this other task leaves the protected object. Blocked tasks are queued on the protected object ordered by time of arrival.Protected object entries are similar to procedures, but additionally have guards. If a guard evaluates to false, a calling task is blocked and added to the queue of that entry; now another task can be admitted to the protected object, as no task is currently executing inside the protected object. Guards are re-evaluated whenever a task leaves the protected object, as this is the only time when the evaluation of guards can have changed. Calls to entries can be requeued to other entries with the same signature. A task that is requeued is blocked and added to the queue of the target entry; this means that the protected object is released and allows admission of another task.  The select statement in Ada can be used to implement non-blocking entry calls and accepts, non-deterministic selection of entries (also with guards), time-outs and aborts. The following example illustrates some concepts of concurrent programming in Ada. with Ada.Text_IO; use Ada.Text_IO;procedure Traffic is   type Airplane_ID is range 1..10;         -- 10 airplanes (= tasks)   task type Airplane(ID: Airplane_ID);     -- task type representing airplanes   type Airplane_Access is access Airplane; -- access type (reference) to Airplane   protected type Runway is             -- a protected object - the shared runway      entry Assign_Aircraft(ID: Airplane_ID);      entry Cleared_Runway (ID : Airplane_ID);      entry Wait_For_Clear;   private      Clear: Boolean := True; -- protected private data - generally more than just a flag...   end Runway;   type Runway_Access is access all Runway;   -- the air traffic controller takes requests for takeoff and landing   task type Controller(My_Runway: Runway_Access) is      entry Request_Takeoff (ID: in Airplane_ID; Takeoff: out Runway_Access);      entry Request_Approach(ID: in Airplane_ID; Approach: out Runway_Access);   end Controller;   Runway1    : aliased Runway;             -- instantiate a runway   Controller1: Controller(Runway1Access); -- and a controller to manage it  ------ the implementations of the above types ------   protected body Runway is      entry Assign_Aircraft (ID : Airplane_ID)when Clear is   -- the entry guard - tasks are blocked until this is true      begin      Clear := False;     Put_Line (Airplane_IDImage (ID) &amp; " on runway ");      end;      entry Cleared_Runway (ID : Airplane_ID) when not Clear is      begin         Clear := True;     Put_Line (Airplane_IDImage (ID) &amp; " cleared runway ");      end;      entry Wait_For_Clear when Clear is begin         null;      end;   end Runway;   task body Controller is   begin      loop         My_Runway.Wait_For_Clear;   -- wait until runway is available         select                      -- wait for two types of requests            when Request_Approachcount = 0 =&gt;  -- landings have priority             accept Request_Takeoff (ID : in Airplane_ID; Takeoff : out Runway_Access) do               My_Runway.Assign_Aircraft (ID);  -- reserve runway               Takeoff := My_Runway;            -- tell airplane which runway            end Request_Takeoff;                -- end of the synchronised part         or            accept Request_Approach (ID : in Airplane_ID; Approach : out Runway_Access) do               My_Runway.Assign_Aircraft (ID);               Approach := My_Runway;            end Request_Approach;         or                          -- terminate if nobody left who could call            terminate;         end select;      end loop;   end;   task body Airplane is      Rwy : Runway_Access;   begin      Controller1.Request_Takeoff (ID, Rwy); -- wait to be cleared for takeoff      Put_Line (Airplane_IDImage (ID) &amp; "  taking off...");  delay 2.0;      Rwy.Cleared_Runway (ID);      delay 5.0; -- fly around a bit...      loop         select   -- try to request a runway            Controller1.Request_Approach (ID, Rwy); -- this is a blocking call            exit; -- if call returned were clear for landing - proceed...         or delay 3.0;  -- timeout - if no answer in 3 seconds, do something else            Put_Line (Airplane_IDImage (ID) &amp; "   in holding pattern");         end select;      end loop;      delay 4.0;  -- do landing approach...      Put_Line (Airplane_IDImage (ID) &amp; "            touched down!");      Rwy.Cleared_Runway(ID);  -- notify runway that were done here.   end;   New_Airplane: Airplane_Access;begin   for I in Airplane_IDRange loop  -- create a few airplane tasks      New_Airplane := new Airplane(I); delay 3.0;   end loop;end Traffic; ==A pragma is a compiler directive that convey information to the compiler to allow specific manipulation of compiled output. United States Government.   Retrieved April 8, 2011.   Certain pragmas are built in to the language United States Government.   Retrieved April 8, 2011.  while other are implementation-specific.Examples of common usage of compiler pragmas would be to disable certain features, such as run-time type checking or array subscript boundary checking, or to instruct the compiler to insert object code in lieu of a function call (as C/C++ does with inline functions). APSE – a specification for a programming environment to support software development in Ada* List of programming languages* SPARK (programming language) – a programming language consisting of a highly restricted subset of the Ada, annotated with meta information describing desired component behavior and individual runtime requirements* VHDL – a hardware description language originally developed at the behest of the U.S Department of Defense that borrows heavily from Ada in both concepts and syntax* PL/SQL* JOVIAL – an earlier U.S Military programming language* Ravenscar profile* Comparison of programming languages* Straw man proposal   ==* ISO 8652|ISO/IEC 8652: Information technology&amp;mdash;Programming languages&amp;mdash;Ada*  )*  ) IEEE Standard 1003.5b-1996, the POSIX Ada binding IDL to Ada mapping==(These documents have been published in various forms including print.)*  *  *  ==* Grady Booch: Software Engineering with Ada, California: The Benjamin/Cummings Publishing Company, Inc., 1987. ISBN 0-8053-0604-8* Jan Skansholm: Ada&amp;nbsp;95 From the Beginning, Addison-Wesley, ISBN 0-201-40376-5* Geoff Gilpin: Ada: A Guided Tour and Tutorial, Prentice hall, ISBN 978-0-13-004045-9 John Barnes: Programming in Ada&amp;nbsp;2005, Addison-Wesley, ISBN 0-321-34078-7 John Barnes: Programming in Ada plus Language Reference Manual, Addison-Wesley, ISBN 0-201-56539-0 John Barnes: Programming in Ada&amp;nbsp;95, Addison-Wesley, ISBN 0-201-34293-6 John Barnes: High Integrity Ada: The SPARK Approach, Addison-Wesley, ISBN 0-201-17517-7 John Barnes: High Integrity Software: The SPARK Approach to Safety and Security, Addison-Wesley, ISBN 0-321-13616-0* John Beidler: Data Structures and Algorithms: An Object-Oriented Approach Using Ada&amp;nbsp;95, Springer-Verlag, ISBN 0-387-94834-1* Dean W. Gonzalez: Ada Programmers Handbook, Benjamin-Cummings Publishing Company, ISBN 0-8053-2529-8* M. Ben-Ari: Ada for Software Engineers, John Wiley &amp; Sons, ISBN 0-471-97912-0* Norman Cohen: Ada as a Second Language, McGraw-Hill Science/Engineering/Math, ISBN 0-07-011607-5* Alan Burns, Andy Wellings: Real-Time Systems and Programming Languages. Ada&amp;nbsp;95, Real-Time Java and Real-Time POSIX., Addison-Wesley, ISBN 0-201-72988-1* Alan Burns, Andy Wellings: Concurrency in Ada, Cambridge University Press, ISBN 0-521-62911-X* Colin Atkinson: Object-Oriented Reuse, Concurrency and Distribution: An Ada-Based Approach, Addison-Wesley, ISBN 0-201-56527-7* Grady Booch, Doug Bryan: Software Engineering with Ada, Addison-Wesley, ISBN 0-8053-0608-0* Daniel Stubbs, Neil W. Webre: Data Structures with Abstract Data Types and Ada, Brooks Cole, ISBN 0-534-14448-9* Pascal Ledru: Distributed Programming in Ada with Protected Objects, Dissertation.com, ISBN 1-58112-034-6* Fintan Culwin: Ada, a Developmental Approach, Prentice Hall, ISBN 0-13-264680-3* John English, Fintan Culwin: Ada&amp;nbsp;95 the Craft of Object Oriented Programming, Prentice Hall, ISBN 0-13-230350-7* David A. Wheeler: Ada&amp;nbsp;95, Springer-Verlag, ISBN 0-387-94801-5* David R. Musser, Alexander Stepanov: The Ada Generic Library: Linear List Processing Packages, Springer-Verlag, ISBN 0-387-97133-5* Michael B. Feldman: Software Construction and Data Structures with Ada&amp;nbsp;95, Addison-Wesley, ISBN 0-201-88795-9* Simon Johnston: Ada&amp;nbsp;95 for C and C++ Programmers, Addison-Wesley, ISBN 0-201-40363-3 Elliot B. Koffman: Ada&amp;nbsp;95, Addison-Wesley, ISBN 0-201-36123-X* Nell Dale, Chip Weems, John McCormick: Programming and Problem Solving with Ada&amp;nbsp;95, Jones &amp; Bartlett Publishers, ISBN 0-7637-0293-5* Nell Dale, John McCormick: Ada Plus Data Structures: An Object-Oriented Approach, 2nd edition, Jones &amp; Bartlett Publishers, ISBN 0-7637-3794-1* Bruce C. Krell: Developing With Ada: Life-Cycle Methods, Bantam Dell Pub Group, ISBN 0-553-09102-6* Judy Bishop: Distributed Ada: Developments and Experiences, Cambridge University Press, ISBN 0-521-39251-9* Bo Sanden: Software Systems Construction With Examples in Ada, Prentice Hall, ISBN 0-13-030834-X* Bruce Hillam: Introduction to Abstract Data Types Using Ada, Prentice Hall, ISBN 0-13-045949-6* David Rudd: Introduction to Software Design and Development With Ada, Brooks Cole, ISBN 0-314-02829-3* Ian C. Pyle: Developing Safety Systems: A Guide Using Ada, Prentice Hall, ISBN 0-13-204298-3* Louis Baker: Artificial Intelligence With Ada, McGraw-Hill, ISBN 0-07-003350-1* Alan Burns, Andy Wellings: HRT-HOOD: A Structured Design Method for Hard Real-Time Ada Systems, North-Holland, ISBN 0-444-82164-3* Walter Savitch, Charles Peterson: Ada: An Introduction to the Art and Science of Programming, Benjamin-Cummings Publishing Company, ISBN 0-8053-7070-6* Mark Allen Weiss: Data Structures and Algorithm Analysis in Ada, Benjamin-Cummings Publishing Company, ISBN 0-8053-9055-3* Henry Ledgard: ADA:  AN INTRODUCTION  (Second Edition), Springer-Verlag, ISBN 0-387-90814-5* Dines Bjørner; Ole N. Oest (eds.): Towards a Formal Description of Ada, London: Springer-Verlag, 1980. ISBN 3-540-10283-3==*  . Charles Babbage Institute, University of Minnesota, Minneapolis. &lt;!--       | PLEASE BE CAUTIOUS IN ADDING MORE LINKS TO THIS ARTICLE. Wikipedia  |    | is not a collection of links nor should it be used for advertising. |    |                                                                     |    |           Excessive or inappropriate links WILL BE DELETED.         |    | See   &amp;   for details.  |    |                                                                     |    | If there are already plentiful links, please propose additions or   |    | replacements on this articles discussion page, or submit your link |    | to the relevant category at the Open Directory Project (dmoz.org)   |    | and link back to that category using the   template.         |    ====--&gt;  *  *  *  *  *</body></html>